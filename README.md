**Aggregate And Consistency-Boundaries**

*Invariant, Constraint, Consistency*

- 제약조건: 모델이 가질 수 있는 제약조건. ex) 배치는 하나 이상 할당될 수 없다.


- 불변: 반드시 참임을 보장할 수 있는 컨디션 ex) 배치 0개(O), 배치 1개(O), 배치 2개(X)


- 락: 동시성 환경에서 불변임을 보장하기 위한 방법. 동일한 로우나 테이블에 대해 동시에 동작이 실행되는 것을 방지해준다.

*Aggregate*

- 매번 수많은 요청이 올 때마다, 항상 락을 걸 수 없다면 어떻게 해야 할까? 불변을 유지하면서 동시성의 혜택을 누릴 방법은 없을까?


- 불변을 유지한다는 것은 동시적인 writing을 방지한다는 의미이다.


- **Aggregate 패턴**: DDD를 사용할 때, 이러한 일관성 문제를 해결하기 위한 패턴이다. 의자라는 상품과 책상이라는 상품이 있다고 가정하자. 의자와 의자는 동시에 수정이 이루어지면 안된다. 하지만 의자와 책상은 동시에 수정이 이루어져도 문제가 없다. Aggregate는 다른 연관된 도메인 오브젝트의 묶음을 하나의 유닛에서 처리할 수 있도록 도와주는 도메인 오브젝트이다.


- 모델의 관계가 복잡해질수 있기 때문에, 하나의 엔티티를 하나의 앤트리 포인트로 삼는 것이 좋다. 이렇게하면 하나의 앤티티를 통해서만 다른 관계된 오브젝트를 수정할 수 있다는 이점이 있다. 퍼블릭 -프라이빗 관계로 이해할수도 있다.


- 예를 들면 장바구니를 사용하는 경우를 생각할 수 있다. 장바구니에 사과, 바나나, 레몬이 담겨있다면 각각의 테이블에 대한 쓰기 연산은 동시에 이루어져도 무관하다. 단, 중요한 것은 장바구니에 대한 트랜잭션 처리는 신경쎠야 한다. 하지만 이를 통해 우리는 동시성이 가져다주는 혜택을 누릴 수 있다.


- 위의 예를 통해 생각해보면, 각 각의 장바구니는 각자의 Consistency-Boundaries를 가진다고 생각할 수 있다. 이 각각의 Consistency-Boundaries는 그 들만의 불변에 대한 책임을 진다. 


*Choosing an Aggregate*

- Aggregate는 동시성 환경에서 모든 연산이 마무리되는 종착지를 의미한다. 작은 단위로 묶을 수록 좋은 성능을 보장한다. 


- 어떤 액션을 취할지를 기준으로 문맥을 결정한다.


- 문맥의 수가 적고, 관리 가능한 사이즈로 유지할 수 있도록 대표를 정하는 것이 좋다.

*Aggregates, Bounded Context, Microservies*

- Bounded Context 전략: 단 하나의 모델로 모든 경우의 수를 커버하는 대신, 쪼개진 모델의 결합으로써 맥락을 만들고, 이를 통해 트랜잭션을 관리하는 것이다.